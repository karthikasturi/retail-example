# GitHub Copilot Instructions - Retail Example Project

## Project Overview
This is a production-grade retail application with a microservices architecture, designed for scalability, reliability, and maintainability.

## Technology Stack

### Backend
### Backend
- **Framework**: Python FastAPI 0.110.0+
- **Database**: PostgreSQL 18.1+
- **ORM**: SQLAlchemy 2.0.45+ with Alembic 1.13.3 for migrations
- **API Documentation**: OpenAPI/Swagger (auto-generated by FastAPI)
- **Authentication**: JWT tokens with refresh token rotation
- **Validation**: Pydantic v2.12.5 models

### Frontend
### Frontend
- **Framework**: Next.js 14.x (App Router)
- **Styling**: Tailwind CSS 3.4.x
- **State Management**: React Context API / Zustand for complex state
- **API Client**: Axios with interceptors for auth
- **UI Components**: shadcn/ui or custom components with Tailwind

### Testing
### Testing
- **Backend Testing**: pytest with pytest-asyncio, pytest-cov (>80% coverage)
- **Frontend Testing**: Jest 29.x + React Testing Library
- **E2E Testing**: Playwright 1.44.x with multi-browser support
- **API Testing**: pytest with httpx AsyncClient
- **Load Testing**: Locust or k6

### Infrastructure & DevOps
### Infrastructure & DevOps
- **Containerization**: Docker 25.x with multi-stage builds
- **Orchestration**: Docker Compose for local, production-ready Dockerfiles
- **IaC**: Terraform 1.8.x for AWS infrastructure provisioning
- **Configuration Management**: Ansible 12.x for EC2 configuration and deployment
- **CI/CD**: GitHub Actions with environment-specific workflows
- **Secrets Management**: AWS Secrets Manager / GitHub Secrets

### Monitoring & Observability
### Monitoring & Observability
- **Metrics**: Prometheus 3.8.1 with custom application metrics
- **Visualization**: Grafana 12.3.1 dashboards for business and technical metrics
- **Logging**: Structured JSON logging with correlation IDs
- **Tracing**: OpenTelemetry for distributed tracing (optional)
- **Alerting**: Prometheus Alertmanager with PagerDuty/Slack integration

## Project Structure

```
.
├── backend/
│   ├── app/
│   │   ├── api/              # API endpoints and routers
│   │   ├── core/             # Configuration, security, dependencies
│   │   ├── models/           # SQLAlchemy models
│   │   ├── schemas/          # Pydantic schemas
│   │   ├── services/         # Business logic layer
│   │   ├── repositories/     # Data access layer
│   │   ├── middleware/       # Custom middleware
│   │   └── utils/            # Utility functions
│   ├── tests/                # pytest tests
│   ├── alembic/              # Database migrations
│   ├── Dockerfile
│   ├── requirements.txt
│   └── pyproject.toml
├── frontend/
│   ├── src/
│   │   ├── app/              # Next.js app directory
│   │   ├── components/       # Reusable components
│   │   ├── lib/              # Utilities and API clients
│   │   ├── hooks/            # Custom React hooks
### Backend
```
# Database
DATABASE_URL=postgresql+asyncpg://user:pass@host:5432/dbname  # PostgreSQL 18.1+
DATABASE_POOL_SIZE=20

# Security
SECRET_KEY=<strong-random-key>
JWT_SECRET_KEY=<strong-random-key>
JWT_ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30
REFRESH_TOKEN_EXPIRE_DAYS=7

# CORS
ALLOWED_ORIGINS=https://example.com,https://www.example.com

# External Services
REDIS_URL=redis://localhost:6379/0
EMAIL_HOST=smtp.example.com
EMAIL_PORT=587

# Monitoring
PROMETHEUS_PORT=9090  # Prometheus 3.8.1
LOG_LEVEL=INFO
```
│   │   ├── types/            # TypeScript types
│   │   └── styles/           # Global styles
│   ├── tests/                # Jest and Playwright tests
│   ├── public/               # Static assets
│   ├── Dockerfile
│   ├── package.json
│   └── tailwind.config.ts
### Frontend
```
NEXT_PUBLIC_API_URL=https://api.example.com/api/v1  # Next.js 14.x
NEXT_PUBLIC_WS_URL=wss://api.example.com/ws
NEXT_PUBLIC_ENV=production
```
├── infrastructure/
 - **API Response Time**: p95 < 200ms, p99 < 500ms
 - **Frontend Load Time**: First Contentful Paint < 1.5s
 - **Database Query Time**: p95 < 100ms (PostgreSQL 18.1+)
 - **Uptime SLA**: 99.9% (43.8 minutes downtime/month)
 - **Error Rate**: < 0.1% of requests
│   │   ├── playbooks/
 *Last Updated: January 2026 (Stack: FastAPI 0.110.0, PostgreSQL 18.1, SQLAlchemy 2.0.45, Alembic 1.13.3, Pydantic 2.12.5, Next.js 14.x, Tailwind CSS 3.4.x, Jest 29.x, Playwright 1.44.x, Prometheus 3.8.1, Grafana 12.3.1, Docker 25.x, Terraform 1.8.x, Ansible 12.x, Python 3.13.11)*
│   │   └── inventory/
│   └── monitoring/           # Prometheus/Grafana configs
│       ├── prometheus/
│       └── grafana/
├── .github/
│   ├── workflows/            # CI/CD pipelines
│   └── copilot-instructions.md
└── docker-compose.yml        # Local development environment
```

## Coding Standards & Best Practices

### Backend (Python/FastAPI)

1. **Code Style**
   - Follow PEP 8 and use Black formatter (line length: 100)
   - Use type hints for all function parameters and return values
   - Use Ruff for linting and import sorting

2. **API Design**
   - RESTful endpoints with proper HTTP methods (GET, POST, PUT, PATCH, DELETE)
   - Versioned APIs: `/api/v1/`
   - Use dependency injection for database sessions and current user
   - Implement proper pagination (limit/offset or cursor-based)
   - Return consistent error responses with proper status codes

3. **Database**
   - Use async SQLAlchemy for all database operations
   - Create Alembic migrations for all schema changes
   - Use database indexes for frequently queried fields
   - Implement soft deletes for important entities
   - Use connection pooling with proper limits

4. **Security**
   - Validate all inputs using Pydantic models
   - Sanitize outputs to prevent XSS
   - Use parameterized queries (SQLAlchemy prevents SQL injection)
   - Implement rate limiting on public endpoints
   - Use CORS middleware with specific origins (not *)
   - Hash passwords with bcrypt (cost factor: 12)
   - Implement CSRF protection for state-changing operations

5. **Performance**
   - Use async/await for I/O operations
   - Implement caching with Redis for frequently accessed data
   - Use database query optimization (select only needed columns)
   - Implement background tasks with Celery or FastAPI BackgroundTasks
   - Use connection pooling for external services

6. **Error Handling**
   - Create custom exception classes for business logic errors
   - Use FastAPI exception handlers for consistent error responses
   - Log errors with full context and stack traces
   - Never expose internal errors to clients

### Frontend (Next.js/React)

1. **Code Style**
   - Use TypeScript strict mode
   - Follow Airbnb React style guide
   - Use ESLint and Prettier (integrated)
   - Functional components with hooks (no class components)

2. **Component Design**
   - Create small, reusable components
   - Use composition over props drilling
   - Implement proper loading and error states
   - Use Server Components by default, Client Components when needed
   - Follow atomic design principles (atoms, molecules, organisms)

3. **State Management**
   - Use React Server Components for server data
   - Use React hooks (useState, useEffect) for local state
   - Use Context API or Zustand for global state
   - Implement optimistic updates where appropriate

4. **Performance**
   - Implement code splitting and lazy loading
   - Optimize images using Next.js Image component
   - Use React.memo() for expensive components
   - Implement virtual scrolling for large lists
   - Minimize bundle size (analyze with next/bundle-analyzer)

5. **Accessibility**
   - Use semantic HTML elements
   - Implement proper ARIA labels
   - Ensure keyboard navigation works
   - Test with screen readers
   - Maintain WCAG 2.1 AA compliance

6. **API Integration**
   - Create typed API client with error handling
   - Implement request/response interceptors
   - Use React Query or SWR for data fetching
   - Handle authentication token refresh automatically
   - Implement proper loading states and error boundaries

### Testing Standards

1. **Backend Tests (pytest)**
   - Unit tests for services and utilities (fast, isolated)
   - Integration tests for API endpoints with test database
   - Use fixtures for common test data
   - Mock external services (HTTP, email, etc.)
   - Test edge cases and error conditions
   - Minimum 80% code coverage

2. **Frontend Tests**
   - Unit tests for utilities and hooks
   - Component tests with React Testing Library
   - Test user interactions, not implementation
   - Mock API calls with MSW (Mock Service Worker)
   - Accessibility tests with jest-axe

3. **E2E Tests (Playwright)**
   - Test critical user journeys (authentication, checkout, etc.)
   - Run against staging environment before production
   - Test across Chrome, Firefox, and Safari
   - Include mobile viewport tests
   - Generate screenshots on failures

4. **Test Naming**
   - Use descriptive test names: `test_user_can_login_with_valid_credentials`
   - Group related tests in classes or describe blocks
   - Use AAA pattern: Arrange, Act, Assert

### Infrastructure & Deployment

1. **Docker**
   - Use multi-stage builds to minimize image size
   - Run containers as non-root user
   - Use specific base image tags (not `latest`)
   - Implement health checks in Dockerfiles
   - Use .dockerignore to exclude unnecessary files

2. **Terraform**
   - Organize code by environment (dev, staging, prod)
   - Use remote state backend (S3 + DynamoDB)
   - Implement proper tagging for all resources
   - Use modules for reusable components
   - Store sensitive values in AWS Secrets Manager
   - Enable encryption at rest for all data stores

3. **Ansible**
   - Use roles for logical grouping
   - Implement idempotent playbooks
   - Use ansible-vault for sensitive data
   - Tag tasks for selective execution
   - Implement proper error handling and rollback

4. **CI/CD (GitHub Actions)**
   - Separate workflows for different environments
   - Run tests before deployment
   - Build and push Docker images to registry
   - Implement blue-green or rolling deployments
   - Auto-rollback on health check failures
   - Use environment protection rules
   - Implement manual approval for production

5. **AWS EC2 Setup**
   - Use Auto Scaling Groups for high availability
   - Implement proper security groups (least privilege)
   - Use Application Load Balancer with health checks
   - Enable CloudWatch monitoring and logs
   - Use Systems Manager for instance management
   - Implement backup strategies for databases

### Monitoring & Observability

1. **Application Metrics (Prometheus)**
   - Expose `/metrics` endpoint in FastAPI
   - Track request rate, latency, and error rate (RED metrics)
   - Monitor database connection pool usage
   - Track business metrics (orders, revenue, etc.)
   - Implement custom metrics for critical operations

2. **Logging**
   - Use structured JSON logging
   - Include correlation IDs for request tracing
   - Log levels: DEBUG (dev), INFO (staging), WARNING+ (prod)
   - Never log sensitive information (passwords, tokens, PII)
   - Centralize logs with CloudWatch or ELK stack

3. **Grafana Dashboards**
   - Create dashboards for technical metrics (CPU, memory, latency)
   - Create dashboards for business metrics (users, orders, revenue)
   - Set up alerts for critical thresholds
   - Include SLA/SLO tracking

4. **Health Checks**
   - Implement `/health` and `/ready` endpoints
   - Check database connectivity
   - Check external service dependencies
   - Return proper status codes (200, 503)

## Environment Variables

### Backend
```
# Database
DATABASE_URL=postgresql+asyncpg://user:pass@host:5432/dbname
DATABASE_POOL_SIZE=20

# Security
SECRET_KEY=<strong-random-key>
JWT_SECRET_KEY=<strong-random-key>
JWT_ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30
REFRESH_TOKEN_EXPIRE_DAYS=7

# CORS
ALLOWED_ORIGINS=https://example.com,https://www.example.com

# External Services
REDIS_URL=redis://localhost:6379/0
EMAIL_HOST=smtp.example.com
EMAIL_PORT=587

# Monitoring
PROMETHEUS_PORT=9090
LOG_LEVEL=INFO
```

### Frontend
```
NEXT_PUBLIC_API_URL=https://api.example.com/api/v1
NEXT_PUBLIC_WS_URL=wss://api.example.com/ws
NEXT_PUBLIC_ENV=production
```

## Security Checklist

- [ ] All secrets stored in AWS Secrets Manager / GitHub Secrets
- [ ] HTTPS enforced for all endpoints
- [ ] SQL injection prevention (using ORM)
- [ ] XSS prevention (output sanitization)
- [ ] CSRF protection enabled
- [ ] Rate limiting implemented
- [ ] Input validation on all endpoints
- [ ] Secure password hashing (bcrypt)
- [ ] JWT token expiration and refresh
- [ ] Security headers configured (HSTS, CSP, X-Frame-Options)
- [ ] Database backups automated
- [ ] Audit logging for sensitive operations
- [ ] Dependency scanning in CI/CD
- [ ] Container image scanning

## Performance Targets

- **API Response Time**: p95 < 200ms, p99 < 500ms
- **Frontend Load Time**: First Contentful Paint < 1.5s
- **Database Query Time**: p95 < 100ms
- **Uptime SLA**: 99.9% (43.8 minutes downtime/month)
- **Error Rate**: < 0.1% of requests

## Git Workflow

- Use feature branches: `feature/feature-name`
- Use bugfix branches: `bugfix/issue-description`
- Protect main branch (require PR reviews)
- Run CI checks on all PRs
- Squash merge for clean history
- Use conventional commits: `feat:`, `fix:`, `docs:`, `refactor:`, `test:`

## When Generating Code

1. **Always include**:
   - Type hints (Python) or TypeScript types
   - Docstrings for functions and classes
   - Error handling with proper logging
   - Input validation
   - Unit tests for new functions

2. **Consider**:
   - Performance implications
   - Security vulnerabilities
   - Backward compatibility
   - Database migration needs
   - Monitoring and logging

3. **Avoid**:
   - Hardcoded credentials or secrets
   - SQL string concatenation
   - Blocking I/O in async contexts
   - Overly complex logic (prefer simplicity)
   - Code duplication

## Common Patterns to Use

### Backend: Repository Pattern
```python
class UserRepository:
    async def get_by_id(self, db: AsyncSession, user_id: int) -> User | None:
        result = await db.execute(select(User).where(User.id == user_id))
        return result.scalar_one_or_none()
```

### Backend: Service Layer
```python
class UserService:
    def __init__(self, repo: UserRepository):
        self.repo = repo
    
    async def get_user(self, db: AsyncSession, user_id: int) -> UserSchema:
        user = await self.repo.get_by_id(db, user_id)
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        return UserSchema.from_orm(user)
```

### Frontend: API Client
```typescript
export async function fetchUser(id: string): Promise<User> {
  const response = await apiClient.get(`/users/${id}`);
  return response.data;
}
```

### Frontend: Error Boundary
```typescript
export default function ErrorBoundary({ error }: { error: Error }) {
  return (
    <div className="flex min-h-screen items-center justify-center">
      <div className="text-center">
        <h2 className="text-2xl font-bold text-red-600">Something went wrong</h2>
        <p className="mt-2 text-gray-600">{error.message}</p>
      </div>
    </div>
  );
}
```

## Priority Guidelines

When suggesting code or making decisions:
1. **Security** - Always prioritize security over convenience
2. **Correctness** - Code must work correctly before optimization
3. **Maintainability** - Write code that's easy to understand and modify
4. **Performance** - Optimize critical paths, profile before optimizing
5. **User Experience** - Fast, responsive, accessible interfaces

---

*Last Updated: January 2026*
*For questions or updates, contact the development team.*
